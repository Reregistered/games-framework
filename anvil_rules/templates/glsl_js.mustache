// Autogenerated by GF - do not modify

goog.provide('{{namespace}}.{{className}}');

goog.require('gf');
goog.require('gf.assets.ContentLoader');
goog.require('gf.assets.Observer');
goog.require('gf.graphics');
goog.require('gf.graphics.Program');
goog.require('gf.log');
goog.require('goog.string');
goog.require('goog.webgl');



/**
 * @constructor
 * @extends {gf.graphics.Program}
 * @param {!gf.graphics.GraphicsContext} graphicsContext Graphics context.
 * @param {string=} opt_vertexShader Vertex shader source.
 * @param {string=} opt_fragmentShader Fragment shader source.
 */
{{namespace}}.{{className}} = function(graphicsContext,
    opt_vertexShader, opt_fragmentShader) {
  goog.base(this, graphicsContext, '{{className}}',
      opt_vertexShader, opt_fragmentShader);

{{#getAttributes}}
  /** @type {number} */
  this.{{originalName}} = -1;
{{/getAttributes}}

{{#getUniforms}}
  /** @type {WebGLUniformLocation} */
  this.{{originalName}} = null;
{{/getUniforms}}
};
goog.inherits({{namespace}}.{{className}}, gf.graphics.Program);


/**
 * @override
 */
{{namespace}}.{{className}}.prototype.discard = function() {
{{#getAttributes}}
  this.{{originalName}} = -1;
{{/getAttributes}}

{{#getUniforms}}
  this.{{originalName}} = null;
{{/getUniforms}}

  goog.base(this, 'discard');
};


/**
 * Constants declared in JavaScript to be used by shaders.
 * @private
 * @const
 * @type {string}
 */
{{namespace}}.{{className}}.JS_CONST_ =
{{#jsConsts}}
    '#define {{value}} \' +\n' + ({{expression}}) + '\n      \'\\n' +
{{/jsConsts}}
    '';


/**
 * The compiled vertex source code.
 * @private
 * @const
 * @type {string}
 */
{{namespace}}.{{className}}.COMPILED_VERTEX_SHADER_SOURCE_ =
    {{namespace}}.{{className}}.JS_CONST_ +
    '{{{getVertexSource}}}';


/**
 * The compiled fragment source code.
 * @private
 * @const
 * @type {string}
 */
{{namespace}}.{{className}}.COMPILED_FRAGMENT_SHADER_SOURCE_ =
    {{namespace}}.{{className}}.JS_CONST_ +
    '{{{getFragmentSource}}}';


/**
 * The uncompiled vertex source code.
 * @private
 * @const
 * @type {string}
 */
{{namespace}}.{{className}}.UNCOMPILED_VERTEX_SHADER_SOURCE_ =
    {{namespace}}.{{className}}.JS_CONST_ +
    goog.string.unescapeEntities('{{getOriginalVertexSourceXX}}');


/**
 * The uncompiled fragment source code.
 * @private
 * @const
 * @type {string}
 */
{{namespace}}.{{className}}.UNCOMPILED_FRAGMENT_SHADER_SOURCE_ =
    {{namespace}}.{{className}}.JS_CONST_ +
    goog.string.unescapeEntities('{{getOriginalFragmentSourceXX}}');


/**
 * Source JSON file for the program.
 * @const
 * @type {string}
 */
{{namespace}}.{{className}}.SOURCE_JSON = gf.BIN_PATH + '{{templateProperties.json_path}}';


/**
 * Creates an instance of the program, switching to the JSON
 * version when running with a build daemon.
 * @param {!gf.assets.AssetManager} assetManager Asset manager.
 * @param {!gf.graphics.GraphicsContext} context Graphics context.
 * @return {(
 *     !{{namespace}}.{{className}}
 * )} An instance of the atlas.
 */
{{namespace}}.{{className}}.create = function(assetManager, context) {
  if (gf.BUILD_CLIENT && assetManager.runtime.buildClient) {
    return new {{namespace}}.Json{{className}}_(
        assetManager,
        context,
        {{namespace}}.{{className}}.SOURCE_JSON);
  } else {
    return new {{namespace}}.Compiled{{className}}_(context);
  }
};



/**
 * @constructor
 * @private
 * @extends { {{namespace}}.{{className}} }
 * @param {!gf.graphics.GraphicsContext} graphicsContext Graphics context.
 */
{{namespace}}.Compiled{{className}}_ = function(graphicsContext) {
  goog.base(
      this,
      graphicsContext,
      gf.graphics.COMPILED_SHADERS ?
          {{namespace}}.{{className}}.COMPILED_VERTEX_SHADER_SOURCE_ :
          {{namespace}}.{{className}}.UNCOMPILED_VERTEX_SHADER_SOURCE_,
      gf.graphics.COMPILED_SHADERS ?
          {{namespace}}.{{className}}.COMPILED_FRAGMENT_SHADER_SOURCE_ :
          {{namespace}}.{{className}}.UNCOMPILED_FRAGMENT_SHADER_SOURCE_);
};
goog.inherits({{namespace}}.Compiled{{className}}_, {{namespace}}.{{className}});


/**
 * @override
 */
{{namespace}}.Compiled{{className}}_.prototype.endRestoring = function() {
  var gl = this.graphicsContext.gl;

  if (!goog.base(this, 'endRestoring') || !this.handle) {
    return false;
  }

{{#getAttributes}}
  this.{{originalName}} = gl.getAttribLocation(
      this.handle,
      gf.graphics.COMPILED_SHADERS ? '{{shortName}}' : '{{originalName}}');
{{/getAttributes}}

{{#getUniforms}}
  this.{{originalName}} = gl.getUniformLocation(
      this.handle,
      gf.graphics.COMPILED_SHADERS ? '{{shortName}}' : '{{originalName}}');
{{/getUniforms}}
};



/**
 * @constructor
 * @private
 * @implements {gf.assets.Observer}
 * @extends { {{namespace}}.{{className}} }
 * @param {!gf.assets.AssetManager} assetManager Asset manager.
 * @param {!gf.graphics.GraphicsContext} graphicsContext Graphics context.
 * @param {string} path Path to the program metadata.
 */
{{namespace}}.Json{{className}}_ =
    function(assetManager, graphicsContext, path) {
  goog.base(this, graphicsContext);

  /**
   * Asset manager used for loads.
   * @private
   * @type {!gf.assets.AssetManager}
   */
  this.assetManager_ = assetManager;

  /**
   * Path to the JSON metadata file.
   * @private
   * @type {string}
   */
  this.jsonPath_ = path;

  /**
   * A deferred used for loading.
   * @private
   * @type {goog.async.Deferred}
   */
  this.jsonLoadingDeferred_ = null;

  /**
   * Uniform name map.
   * @private
   * @type {Object}
   */
  this.uniformMap_ = null;

  /**
   * Attribute name map.
   * @private
   * @type {Object}
   */
  this.attributeMap_ = null;

  // Observe changes
  var runtime = this.assetManager_.runtime;
  if (runtime.buildClient) {
    runtime.buildClient.addObserver(this);
  }
};
goog.inherits({{namespace}}.Json{{className}}_, {{namespace}}.{{className}});


/**
 * @override
 */
{{namespace}}.Json{{className}}_.prototype.disposeInternal = function() {
  // Stop observing
  var runtime = this.assetManager_.runtime;
  if (runtime.buildClient) {
    runtime.buildClient.removeObserver(this);
  }

  if (this.jsonLoadingDeferred_) {
    this.jsonLoadingDeferred_.cancel();
    this.jsonLoadingDeferred_ = null;
  }

  goog.base(this, 'disposeInternal');
};


/**
 * @override
 */
{{namespace}}.Json{{className}}_.prototype.notifyAssetsChanged = function(tags) {
  for (var n = 0; n < tags.length; n++) {
    if (tags[n] == this.jsonPath_) {
      gf.log.write('Program ' + this.name + ' modified, reloading...');
      this.load();
      break;
    }
  }
};


/**
 * @override
 */
{{namespace}}.Json{{className}}_.prototype.load = function() {
  this.beginLoadingMetadata_(this.jsonPath_);
};


/**
 * Starts loading the texture metadata.
 * @private
 * @param {string} path JSON metadata path.
 */
{{namespace}}.Json{{className}}_.prototype.beginLoadingMetadata_ = function(path) {
  var assetLoader = new gf.assets.ContentLoader(
      this.jsonPath_, gf.assets.ContentLoader.Type.JSON);
  this.jsonLoadingDeferred_ = this.assetManager_.load(assetLoader);
  this.jsonLoadingDeferred_.addCallbacks(
      this.handleJsonLoad_, this.handleJsonError_, this);
};


/**
 * Handles successful metadata load events.
 * @private
 * @param {!Object} content Content.
 */
{{namespace}}.Json{{className}}_.prototype.handleJsonLoad_ = function(content) {
  this.jsonLoadingDeferred_ = null;

  var blob = content[gf.graphics.COMPILED_SHADERS ? 'compiled' : 'uncompiled'];

  this.vertexShaderSource = {{namespace}}.{{className}}.JS_CONST_ + blob['vertexShader'];
  this.fragmentShaderSource = {{namespace}}.{{className}}.JS_CONST_ + blob['fragmentShader'];
  this.uniformMap_ = blob['uniformMap'];
  this.attributeMap_ = blob['attributeMap'];

  this.restore();
};


/**
 * Handles failed metadata load events.
 * @private
 * @param {Object} arg Error details.
 */
{{namespace}}.Json{{className}}_.prototype.handleJsonError_ = function(arg) {
  this.jsonLoadingDeferred_ = null;
  gf.log.write('Unable to load program ' + this.name, arg);
};


/**
 * @override
 */
{{namespace}}.Json{{className}}_.prototype.endRestoring = function() {
  var gl = this.graphicsContext.gl;

  if (!goog.base(this, 'endRestoring') || !this.handle) {
    return false;
  }
  if (!this.uniformMap_ || !this.attributeMap_) {
    return false;
  }

{{#getAttributes}}
  this.{{originalName}} = gl.getAttribLocation(
      this.handle,
      this.attributeMap_['{{originalName}}']);
{{/getAttributes}}

{{#getUniforms}}
  this.{{originalName}} = gl.getUniformLocation(
      this.handle,
      this.uniformMap_['{{originalName}}']);
{{/getUniforms}}

  return true;
};
